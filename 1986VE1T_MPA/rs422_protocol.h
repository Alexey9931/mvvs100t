/*!
 \file
 \brief Заголовочный файл с описанием API протокола обмена данными по интерфейсу RS-422
*/

#ifndef __PROTOCOL_H
#define __PROTOCOL_H

#include "uart.h"
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <stdlib.h>
#include <math.h>

#define NUMBER_CMDS_IN_PACKET 255             		///< Максимальное число команд в одном пакете

///Заголовок пакета
#define PACKET_HEAD 0x55	
///Хвост пакета
#define PACKET_TAIL 0xAAAA

///Состояния автомата выбора УМ
#define PLC_CM_UNKNOWN_STATE 		0x10	///<Неизвестное состояние
#define PLC_CM_INIT_2_BUS 			0x09	///<Модуль инициализирован, управление по шине 2
#define PLC_CM_CRITICAL_FAULT 	0x06	///<Критическая неисправность
#define PLC_CM_REMOVE_INIT 			0x05	///<Управление не осуществляется (снятие инициализации)
#define PLC_CM_INIT_1_BUS 			0x04	///<Модуль инициализирован, управление по шине 1
#define PLC_CM_NOT_INIT 				0x01	///<Модуль не инициализирован

///все поддерживаемые протоколом команды
#define TYPE_CMD 0x00
#define INIT_CMD 0x01
#define READ_CMD 0x02
#define WRITE_CMD 0x03
#define RESET_CMD 0x04
#define CONFIG 0x05

///Коды ошибок обмена данными
typedef enum protocol_errors
{
	NO_ERROR,															///< Нет ошибок
	UART_ERROR,														///< Ошибка работы UART
	CRC_ERROR,														///< Ошибка контрольной суммы
	PM_ADDR_ERROR,												///< Ошибка адресации
	PACKET_ERROR													///< Ошибка структуры пакета
} protocol_error;

///Структура с заголовком для каждой команды внутри одного пакета
typedef struct cmd_header_struct
{
	uint8_t cmd;			///< Команда
	uint16_t result;	///< Результат выполнения команды
	uint16_t length;	///< Длина команды
}__attribute__((packed)) fields_cmd_header;

///Структура с полями данных для каждой команды внутри одного пакета
typedef struct cmd_struct
{
	fields_cmd_header 	header;		///< Заголовок
	uint8_t 						*data;		///< Данные
}__attribute__((packed)) fields_cmd;

///Структура с полями заголовка пакета
typedef struct packet_header_struct
{
	uint8_t 	header;							///< Заголовок
	uint8_t 	receiver_addr;			///< Адрес получателя
	uint8_t 	sender_addr;				///< Адрес отправителя
	uint16_t 	packet_length;			///< Длина пакета
	uint8_t 	service_byte;				///< Сервисный байт
	uint8_t 	cmd_number;					///< Количество команд
}__attribute__((packed)) fields_packet_header;

///Структура с полями конца пакета
typedef struct packet_tail_Struct
{
	uint32_t checksum;		///< Контрольная сумма (CRC32)
	uint16_t end;					///< Конец пакета
}__attribute__((packed)) fields_packet_tail;

///Структура со всеми полями данных пакета
typedef struct tx_rx_packet_struct
{
	fields_packet_header 	packet_header;																	///< Заголовочные поля
	fields_cmd 						cmd_with_data[NUMBER_CMDS_IN_PACKET];						///< Массив полей с содержимым каждой команды
	fields_packet_tail 		packet_tail;																		///< Поля хвоста пакета
}__attribute__((packed)) fields_packet;

/*!
 *	\brief Отправляет пакет данных
 *	\param *uart_struct - Выбранный UART 
 *	\param ext_bus - Номер шины
 *	\return Код ошибки protocol_error
*/
protocol_error transmit_packet(uart_n *uart_struct, uint8_t ext_bus);

/*!
 *	\brief Читает пакет данных
 *	\param *uart_struct - Выбранный UART 
 *	\param ext_bus - Номер шины
 *	\return Код ошибки protocol_error
*/
protocol_error receive_packet(uart_n *uart_struct, uint8_t ext_bus);

/*!
 *	\brief Выполняет требуемые команды
 *	\param ext_bus - Номер шины
 *	\return Код ошибки protocol_error
*/
uint8_t protocol_do_cmds(uint8_t ext_bus);

/*!
 *	\brief Вычисляет контрольную сумму по алгоритму CRC32
 *	\param *buf - Буфер с данными для расчета контрольной суммы
 *	\param len - Длина буфера
 *	\return Контрольная сумма
*/
uint_least32_t crc32(uint8_t *buf, size_t len);

/*!
 *	\brief Заполняет таблицу CRC32
*/
void fill_crc32_table(void);

/*!
 *	\brief Обрабатывает ошибки приема пакетов
 *	\param error - Код ошибки
 *	\param ext_bus - Номер шины
*/
void rx_error_handler(protocol_error error, uint8_t ext_bus);

/*!
 *	\brief Обрабатывает сервисного байта УМ
 *	\param ext_bus - Номер шины
*/
void um_service_byte_handler(uint8_t ext_bus);

/*!
 *	\brief Преобразует слово для передачи в сеть
 *	\param src - Слово
 *	\return Преобразованнное слово
*/
uint32_t* htonl(uint32_t *src);

/*!
 *	\brief Преобразует полуслово для передачи в сеть
 *	\param src - Полуслово
 *	\return Преобразованнное полуслово
*/
uint16_t* htons(uint16_t *src);

#endif /*__PROTOCOL_H */
