//Пример программы для вывода картинки на индикатор MT-12864
#include "MT-12864Av6.h"

// Заводим структуру конфигурации вывода(-ов) порта GPIO
PORT_InitTypeDef GPIOInitStruct;

const char Logo128[8][128];

static uint8_t	page = 0;				//Номер текущей страницы индикатора
static uint8_t	numChar = 0;		//Позиция по горизонтали выводимого байта

//Процедура программной инициализации индикатора
void LCDInit(void)
{	
	// Включаем тактирование портов
	RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTA, ENABLE);
	RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTC, ENABLE);
	RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTE, ENABLE);
	
	// Инициализируем структуру конфигурации вывода(-ов) порта значениями по умолчанию
	PORT_StructInit(&GPIOInitStruct);
	
	// Изменяем значения по умолчанию на необходимые нам настройки
	GPIOInitStruct.PORT_OE		= PORT_OE_OUT;
	GPIOInitStruct.PORT_SPEED	= PORT_SPEED_SLOW;
	GPIOInitStruct.PORT_MODE	= PORT_MODE_DIGITAL;
	
	// Применяем заполненную нами структуру
	PORT_Init(LCD_PORT_Data, &GPIOInitStruct);
	PORT_Init(LCD_PORT_RW_E_RES, &GPIOInitStruct);
	PORT_Init(LCD_PORT_A0_E1_E2, &GPIOInitStruct);
	
	PORT_WriteBit(LCD_PORT_RW_E_RES, LCD_E, 0);				//Начальное значение сигнала индикатору

	Delay_micro(15);																	//Задержка на время больше 10 мкс
	
	WriteCodeL(0xC0);		//Верхнюю строку на 0 
	WriteCodeR(0xC0);		//Верхнюю строку на 0
	
	WriteCodeL(0x3F);		//Display on
	WriteCodeR(0x3F);		//Display on

	LCD_Clear();
}

//Процедура программной инициализации индикатора (эта функция нужна чтобы заново переназначит пины на лсд)
void LCDReInit(void)
{	

	// Инициализируем структуру конфигурации вывода(-ов) порта значениями по умолчанию
	PORT_StructInit(&GPIOInitStruct);
	
	// Изменяем значения по умолчанию на необходимые нам настройки
	GPIOInitStruct.PORT_OE		= PORT_OE_OUT;
	GPIOInitStruct.PORT_SPEED	= PORT_SPEED_SLOW;
	GPIOInitStruct.PORT_MODE	= PORT_MODE_DIGITAL;
	
	// Применяем заполненную нами структуру
	PORT_Init(LCD_PORT_Data, &GPIOInitStruct);
	PORT_Init(LCD_PORT_RW_E_RES, &GPIOInitStruct);
	PORT_Init(LCD_PORT_A0_E1_E2, &GPIOInitStruct);
}

void WriteCodeL(char byte) { WriteByte(byte,0,1,0); }	//Команду в левый кристалл индикатора
void WriteCodeR(char byte) { WriteByte(byte,0,0,1); }	//Команду в правый кристалл индикатора

void WriteDataL(char byte) { WriteByte(byte,1,1,0); }	//Данные в левую половину индикатора
void WriteDataR(char byte) { WriteByte(byte,1,0,1); }	//Данные в правую половину индикатора

char ReadDataL(void) { return ReadByte(1,1,0); }	//Прочитать байт данных из левой половины индикатора
char ReadDataR(void) { return ReadByte(1,0,1); }	//Прочитать байт данных из правой половины индикатора

void SetBusData(char byte)
{	
	// Изменяем значения по умолчанию на необходимые нам настройки
	GPIOInitStruct.PORT_OE		= PORT_OE_OUT;
	
	// Применяем заполненную нами структуру
	PORT_Init(LCD_PORT_Data, &GPIOInitStruct);
	
	PORT_WriteBit(LCD_PORT_Data, LCD_D0, (byte & 0x01));
	PORT_WriteBit(LCD_PORT_Data, LCD_D1, (byte & 0x02));
	PORT_WriteBit(LCD_PORT_Data, LCD_D2, (byte & 0x04));
	PORT_WriteBit(LCD_PORT_Data, LCD_D3, (byte & 0x08));
	PORT_WriteBit(LCD_PORT_Data, LCD_D4, (byte & 0x010));
	PORT_WriteBit(LCD_PORT_Data, LCD_D5, (byte & 0x020));
	PORT_WriteBit(LCD_PORT_Data, LCD_D6, (byte & 0x040));
	PORT_WriteBit(LCD_PORT_Data, LCD_D7, (byte & 0x080));
}

char ReadBusData()
{
	uint8_t byte = 0;
	
	// Изменяем значения по умолчанию на необходимые нам настройки
	GPIOInitStruct.PORT_OE		= PORT_OE_IN;
	
	// Применяем заполненную нами структуру
	PORT_Init(LCD_PORT_Data, &GPIOInitStruct);
	
	byte = (char)PORT_ReadInputData(LCD_PORT_Data) & 0xff;
	
	return (char)byte;
}

//Процедура выдачи байта в индикатор
void WriteByte(char byte, uint8_t cd, uint8_t left, uint8_t right)
{
	if ((left==1)&&(right==1)) return;	//Читать (для опроса готовности) одновременно из обоих кристаллов недопустимо!
	WaitReady(left,right);							//Ждать готовности индикатора
	
	//При необходимости настроить здесь шину данных на вывод
	PORT_ResetBits(LCD_PORT_RW_E_RES, LCD_RW);
	
	PORT_WriteBit(LCD_PORT_A0_E1_E2, LCD_A0, cd);	//Выдача байта в индикатор как данных или команды
	
	PORT_WriteBit(LCD_PORT_A0_E1_E2, LCD_E1, left);
	PORT_WriteBit(LCD_PORT_A0_E1_E2, LCD_E2, right);		//Выбрать нужные нужные кристаллы в индикаторе
	
	SetBusData(byte);													//Выдать байт на шину данных индикатора
	Delay_micro(1);														//Это время предустановки адреса (tAW) >140ns
	PORT_SetBits(LCD_PORT_RW_E_RES, LCD_E);		//Сформировать строб записи в индикатор E=1
	Delay_micro(1);														// >450ns Длительность сигнала E=1 (время предустановки данных попало сюда (tDS))
	PORT_ResetBits(LCD_PORT_RW_E_RES, LCD_E);	//Сбросить сигнал E
	Delay_micro(1);														//Минимально допустимый интервал между сигналами E=1 >(1000ns-140ns-450ns)
}

char ReadByte(uint8_t cd, uint8_t left, uint8_t right)
{
	char byte;
	if ((left==1)&&(right==1)) return 0;	//Читать одновременно из обоих кристаллов недопустимо!
	WaitReady(left,right);								//Ждать готовности индикатора
	PORT_SetBits(LCD_PORT_RW_E_RES, LCD_RW);
	
	PORT_WriteBit(LCD_PORT_A0_E1_E2, LCD_A0, cd);	//Выдача байта в индикатор как данных или команды
	
	PORT_WriteBit(LCD_PORT_A0_E1_E2, LCD_E1, left);
	PORT_WriteBit(LCD_PORT_A0_E1_E2, LCD_E2, right);		//Выбрать нужные нужные кристаллы в индикаторе
	
	Delay_micro(1);										//Это время предустановки адреса (tAW) >140ns
	PORT_SetBits(LCD_PORT_RW_E_RES, LCD_E);		//Выдать строб в индикатор
	Delay_micro(1);										//>450ns Минимально допустимая длительность сигнала E=1 (время доступа (tDDR) попало сюда)
	byte = ReadBusData();							//Прочитать данные с шины индикатора (они на ней уже минимум 130нс)
	PORT_ResetBits(LCD_PORT_RW_E_RES, LCD_E);	//Сбросить сигнал E
	Delay_micro(1);										//Минимально допустимый интервал между сигналами E=1 >(1000ns-140ns-450ns)
	return byte;											//Вернуть прочитанный байт
}

void WaitReady(uint8_t left, uint8_t right)
{	//Ждать готовности индикатора, опрашивая байт статуса
	//При необходимости настроить здесь шину данных на ввод
	
	PORT_SetBits(LCD_PORT_RW_E_RES, LCD_RW);
	PORT_ResetBits(LCD_PORT_A0_E1_E2, LCD_A0);	//Чтение флага занятости
	
	PORT_WriteBit(LCD_PORT_A0_E1_E2, LCD_E1, left);
	PORT_WriteBit(LCD_PORT_A0_E1_E2, LCD_E2, right);		//Выбрать нужные нужные кристаллы в индикаторе	
	
	Delay_micro(1);		//Это время предустановки адреса (tAW) >140ns
	
	PORT_SetBits(LCD_PORT_RW_E_RES, LCD_E);
	Delay_micro(1);										//Минимальная длительность сигнала E=1 >450ns (информация на шину данных индикатором будет выдана раньше, не более чем через 320нс)
	
	// Изменяем значения по умолчанию на необходимые нам настройки
	GPIOInitStruct.PORT_OE		= PORT_OE_IN;
	
	// Применяем заполненную нами структуру
	PORT_Init(LCD_PORT_Data, &GPIOInitStruct);
	
	//Delay_micro(100);
	//while(PORT_ReadInputDataBit (LCD_PORT_Data, LCD_D7) == 1);	//Ждать сброса флага занятости
	
	PORT_ResetBits(LCD_PORT_RW_E_RES, LCD_E);	//Сбросить сигнал E
	
	Delay_micro(1);										//Минимально допустимый интервал между сигналами E=1 >(1000ns-140ns-450ns)
}

void PrintLogo()
{	
	// Переходим на левый край первой строки
	page = 0;		//Номер текущей страницы индикатора
	numChar = 0;		//Позиция по горизонтали выводимого байта
	for(page = 0; page < 8; page++)
	{//Цикл по всем 8-ми страницам индикатора
		WriteCodeL(page|0xB8);		//Установка текущей страницы для левого кристалла индикатора (Set Page)
		WriteCodeL(0x40);			//Установка текущего адреса для записи данных в 0 для левого кристалла индикатора (Set Address)
		for(numChar = 0; numChar < 64; numChar++) {			//Цикл вывода данных в левую половину индикатора
			WriteDataL(Logo128[page][numChar]);	//Вывод очередного байта в индикатор
		}
		WriteCodeR(page|0xB8);		//Установка текущей страницы для правого кристалла индикатора
		WriteCodeR(0x40);			//Установка текущего адреса для записи данных в 0 для правого кристалла индикатора
		for(numChar=64; numChar<128; numChar++) {				//Цикл вывода данных в правую половину индикатора
			WriteDataR(Logo128[page][numChar]);	//Вывод очередного байта в индикатор
		}
	}
}


void LCD_Clear()
{
	// Переходим на левый край первой строки
	page = 0;		//Номер текущей страницы индикатора
	numChar = 0;		//Позиция по горизонтали выводимого байта
	
	WriteCodeL(0|0xB8);		//Установка текущей страницы для левого кристалла индикатора (Set Page)
	WriteCodeL(0x40);			//Установка текущего адреса для записи данных в 0 для левого кристалла индикатора (Set Address)
	
	for(page = 0; page < 8; page++)
	{//Цикл по всем 8-ми страницам индикатора
		WriteCodeL(page|0xB8);		//Установка текущей страницы для левого кристалла индикатора (Set Page)
		WriteCodeL(0x40);			//Установка текущего адреса для записи данных в 0 для левого кристалла индикатора (Set Address)
		for(numChar = 0; numChar < 64; numChar++) {			//Цикл вывода данных в левую половину индикатора
			WriteDataL(0x00);	//Вывод очередного байта в индикатор
		}
		WriteCodeR(page|0xB8);		//Установка текущей страницы для правого кристалла индикатора
		WriteCodeR(0x40);			//Установка текущего адреса для записи данных в 0 для правого кристалла индикатора
		for(numChar=64; numChar<128; numChar++) {				//Цикл вывода данных в правую половину индикатора
			WriteDataR(0x00);	//Вывод очередного байта в индикатор
		}
	}
	// Переходим на левый край первой строки
	page = 0;		//Номер текущей страницы индикатора
	numChar = 0;		//Позиция по горизонтали выводимого байта
}

void LCD_PrintMessageInPosition(wchar_t *message, uint32_t length, uint8_t user_page, uint8_t user_numChar)
{	// Данная функция для отправки массивов байт
	
	// Переходим на левый край первой строки
	page = user_page;		//Номер текущей страницы индикатора
	numChar = user_numChar * (uint8_t)MyFont.width;		//Позиция по горизонтали выводимого байта
	
	LCD_PrintMessageContinue(message, length);
}

void LCD_ClearLine(uint8_t user_page)
{	// Данная функция для отправки массивов байт
	
	// Переходим на левый край первой строки
	page = user_page;		//Номер текущей страницы индикатора
	numChar = 0;		//Позиция по горизонтали выводимого байта
		
	WriteCodeL(page|0xB8);		//Установка текущей страницы для левого кристалла индикатора (Set Page)
	WriteCodeL(numChar | 0x40);			//Установка текущего адреса для записи данных в 0 для левого кристалла индикатора (Set Address)
	
	for(; numChar < 64; numChar++) 
	{			//Цикл вывода данных в левую половину индикатора
		WriteDataL(0x00);	//Вывод очередного байта в индикатор
	}
	WriteCodeR(page | 0xB8);		//Установка текущей страницы для правого кристалла индикатора
	WriteCodeR(numChar | 0x40);			//Установка текущего адреса для записи данных в 0 для правого кристалла индикатора
	
	for(numChar=64; numChar<128; numChar++) {				//Цикл вывода данных в правую половину индикатора
		WriteDataR(0x00);	//Вывод очередного байта в индикатор
	}

	// Переходим на левый край первой строки
	page = user_page;	//Номер текущей страницы индикатора
	numChar = 0;			//Позиция по горизонтали выводимого байта
}

void LCD_PrintMessageNew(wchar_t *message, uint32_t length)
{	// Данная функция для отправки массивов байт
	
	// Переходим на левый край первой строки
	page = 0;		//Номер текущей страницы индикатора
	numChar = 0;		//Позиция по горизонтали выводимого байта
	
	LCD_PrintMessageContinue(message, length);
}

void LCD_PrintMessageContinue(wchar_t *message, uint32_t length)
{	// Данная функция для отправки массивов байт
	
	uint32_t cntBytes = 0;	// Количество выведенных байт
	uint8_t flagSpace = 1;	// Флаг необходимости пробела
	
	if(length == 0) return; // Если длина сообщения равна 0, то выходим
	
	for(; page < 8; page++)
	{//Цикл по всем 8-ми страницам индикатора
		WriteCodeL(page|0xB8);		//Установка текущей страницы для левого кристалла индикатора (Set Page)
		WriteCodeL(numChar|0x40);			//Установка текущего адреса для записи данных в 0 для левого кристалла индикатора (Set Address)
		for(; numChar < 64; numChar++) {			//Цикл вывода данных в левую половину индикатора
			
			// Делаем смещение для кириллицы (т к у нее код больше чем позиция в массиве на 0x390)
			if(message[cntBytes / MyFont.width] > 0xFF) message[cntBytes / MyFont.width] = message[cntBytes / MyFont.width] - 0x390; 
			
			if(flagSpace != 0) // перед каждым символом пробел
			{
				WriteDataL(0x00);
				flagSpace = 0;
			}
			else 
			{	
				WriteDataL(MyFont.fontArray[MyFont.width * ((char)message[cntBytes / MyFont.width] - 0x20) + cntBytes  - (cntBytes / MyFont.width) * MyFont.width]);	//Вывод очередного байта в индикатор
				++cntBytes;
				if((cntBytes % MyFont.width) == 0)	flagSpace = 1;
			}
			if(cntBytes == (MyFont.width) * length) 
			{
				numChar++;
				return;
			}
		}
		WriteCodeR(page|0xB8);		//Установка текущей страницы для правого кристалла индикатора
		WriteCodeR(numChar|0x40);			//Установка текущего адреса для записи данных в 0 для правого кристалла индикатора
		for(; numChar<128; numChar++) {				//Цикл вывода данных в правую половину индикатора
			if(message[cntBytes / MyFont.width] > 0xFF) message[cntBytes / MyFont.width] = message[cntBytes / MyFont.width] - 0x390;
			
			if(flagSpace != 0) // перед каждым символом пробел (поэтому и +1 т к ширина увеличилась)
			{
				WriteDataR(0x00);
				flagSpace = 0;
			}
			else 
			{	
				WriteDataR(MyFont.fontArray[MyFont.width * ((char)message[cntBytes / MyFont.width] - 0x20) + cntBytes  - (cntBytes / MyFont.width) * MyFont.width]);	//Вывод очередного байта в индикатор
				++cntBytes;	
				if((cntBytes % MyFont.width) == 0)	flagSpace = 1;				
			}
			if(cntBytes == (MyFont.width) * length)
			{
				numChar++;
				return;
			}
		}
		numChar = 0;
	}
	page = 0;
}

void LCD_EndLine()
{	// Данная функция для отправки массивов байт
	++page;
	numChar = 0;
}

//Данные изображения, побитые по строкам и байты будут на индикаторе вертикально.
//Это просто последовательность байт для записи в индикатор начиная с верхней страницы.
//Полностью соответствуют картинке распределения ОЗУ в документации на модуль.
const char Logo128[8][128] = //128x64 pixel, каждые 8 вертикальных точек собраны в байт
{
	{	0xFF,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
		0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
		0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
		0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
		0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
		0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
		0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
		0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF
	},
	{	0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xC0,0xE0,0xF0,0xF0,0xF0,
		0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xE0,0xE0,0xE0,0xC0,0x80,0x00,
		0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,
		0x00,0x80,0x80,0x00,0x00,0x80,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x80,0x00,0x00,
		0x80,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x80,
		0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,
		0x00,0x00,0x80,0x00,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x80,0x00,0x00,0x80,0x00,
		0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x3F
	},
	{	0x1F,0xC0,0xE0,0xE0,0xFC,0xFE,0xF3,0xE3,0xE3,0xE3,0xE3,0xAF,0x6F,0xFF,0xFF,0xFF,
		0xBF,0xBF,0xFF,0xFF,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0xFF,0xF6,0xF4,0x1F,0x21,0xE2,0x61,0x6F,0x60,0x6F,0x64,0x6F,0x60,0x6F,0x65,0x68,
		0x60,0x6F,0x62,0x61,0x67,0x68,0x67,0x60,0x6A,0x67,0x60,0x6E,0x61,0x6F,0x60,0x67,
		0x6A,0x6B,0x60,0x6F,0x65,0x68,0x60,0x60,0x6F,0x60,0x60,0x6F,0x62,0x61,0x67,0x68,
		0x67,0x60,0x6F,0x62,0x6F,0x60,0x6F,0x64,0x6F,0x60,0x6F,0x65,0x68,0x64,0x6A,0x6F,
		0x60,0x60,0x6F,0x64,0x6F,0x60,0x60,0x60,0x6F,0x60,0x67,0x6A,0x6B,0x60,0x6D,0x62,
		0x6D,0x60,0x6F,0x62,0x6F,0x60,0x6F,0x64,0x6F,0x60,0x6F,0x65,0x68,0x64,0x6A,0x6F
	},
	{	0xFE,0x3F,0x3F,0x3F,0xBF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xF9,0x77,0x37,
		0x03,0x03,0x01,0x00,0x00,0x00,0x00,0x01,0x07,0x0F,0x13,0x01,0x00,0x00,0x01,0x07,
		0xD7,0x0E,0x08,0xC0,0x00,0x10,0x0F,0xF8,0x00,0x00,0x80,0xE0,0xF8,0xFE,0xFF,0xFF,
		0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0xC0,0xF0,0xFE,0xFF,0xFF,0xFF,0xFE,0x00,0x00,
		0x00,0xE0,0xF0,0xF8,0xFC,0x7C,0x3E,0x1E,0x1F,0x0F,0x0F,0x0F,0x0F,0x1F,0x1E,0x1E,
		0x3E,0x7C,0xFC,0xF8,0xF0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x80,0xC0,0xF0,0xFC,0xFE,0xFF,0xFF,0xFE,0x00,0x00,0x06,0x0F,0x0F,0x0F,0x0F,0x0F,
		0x0F,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x06,0xF0
	},
	{	0x3F,0xE0,0x00,0x00,0x01,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x3F,0x00,0x00,0xE0,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x01,0x01,0xC1,0xE0,0xE0,0xF9,0xFF,0xFC,0xFF,0xFF,0x7F,0x1F,0xFF,0xFF,0xFF,
		0xFF,0xFF,0x80,0xE0,0xF8,0xFE,0xFF,0xFF,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,
		0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x30,0x78,0x78,0xFC,0xFC,0xFC,0xFC,0x78,0x78,
		0x30,0x00,0x01,0x07,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x80,0xE0,0xF8,0xFE,
		0xFF,0xFF,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF
	},
	{	0xFC,0x01,0x03,0x04,0x18,0x20,0x40,0x81,0x87,0x07,0x07,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
		0x80,0xE4,0xE7,0xFB,0xFF,0xFF,0x7F,0x3F,0x0F,0x03,0x01,0x00,0x00,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0x7F,0x1F,0x07,0x03,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,
		0x00,0x70,0xF8,0xF8,0xF0,0xE0,0xE0,0xC0,0xC0,0x80,0x80,0x80,0x80,0xC0,0xC0,0xC0,
		0xE0,0xF0,0xFC,0xFF,0x7F,0x3F,0x0F,0x81,0xE0,0xF8,0xFC,0xFF,0xFF,0x3F,0x1F,0x07,
		0x01,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF
	},
	{	0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x04,0x04,0x04,0x0C,
		0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x04,0x04,0x04,0x02,0x03,0x01,0x00,
		0x00,0x03,0x07,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x07,0x07,
		0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x07,0x07,0x07,0x03,0x00,0x00,
		0x00,0x00,0x00,0x01,0x01,0x03,0x03,0x03,0x07,0x07,0x07,0x07,0x07,0x07,0x03,0x03,
		0x03,0x01,0x01,0x00,0x00,0x00,0x00,0x03,0x07,0x07,0x07,0x03,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x03,0x07,0x07,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x03,0x07,0x07,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF
	},
	{	0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
		0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
		0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
		0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
		0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
		0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
		0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
		0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF
	}
};
